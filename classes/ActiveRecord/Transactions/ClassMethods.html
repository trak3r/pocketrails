<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
<meta content="width=device-width; initial-scale=1.0; minimum-scale=1.0; maximum-scale=1.0; user-scalable=0;" name="viewport"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
    <title>
      Module: ActiveRecord::Transactions::ClassMethods
    </title>
  </head>
  <body>

<div class="toolbar">
    <h1 id="pageTitle">
        ActiveRecord::Transactions::ClassMethods
    </h1>
</div>
<div id="ActiveRecord::Transactions::ClassMethods" title="ActiveRecord::Transactions::ClassMethods" class="panel">
<script type="text/javascript"><!--
google_ad_client = "pub-3648329338598531";
/* Pocket Rails */
google_ad_slot = "9128679516";
google_ad_width = 234;
google_ad_height = 60;
//-->
</script>
<script type="text/javascript"
src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>
<hr />

    <h2>Files</h2>
    <fieldset>
        <div class="row">
            <ul>
                <li>
                    <a href="../../../files/activerecord/lib/active_record/transactions_rb.html">activerecord/lib/active_record/transactions.rb</a>
                </li>
            </ul>
        </div>
    </fieldset>
 <!-- banner header -->



<h2>Description</h2><fieldset><div class='row'><p>
<a href="../Transactions.html">Transactions</a> are protective blocks where
SQL statements are only permanent if they can all succeed as one atomic
action. The classic example is a transfer between two accounts where you
can only have a deposit if the withdrawal succeeded and vice versa. <a
href="../Transactions.html">Transactions</a> enforce the integrity of the
database and guard the data against program errors or database break-downs.
So basically you should use <a
href="ClassMethods.html#M001483">transaction</a> blocks whenever you have a
number of statements that must be executed together or not at all. Example:
</p>
<pre>
  ActiveRecord::Base.transaction do
    david.withdrawal(100)
    mary.deposit(100)
  end
</pre>
<p>
This example will only take money from David and give to Mary if neither
<tt>withdrawal</tt> nor <tt>deposit</tt> raises an exception. Exceptions
will force a ROLLBACK that returns the database to the state before the <a
href="ClassMethods.html#M001483">transaction</a> was begun. Be aware,
though, that the objects will <em>not</em> have their instance data
returned to their pre-transactional state.
</p>
<h2>Different Active Record classes in a single <a href="ClassMethods.html#M001483">transaction</a></h2>
<p>
Though the <a href="ClassMethods.html#M001483">transaction</a> class method
is called on some Active Record class, the objects within the <a
href="ClassMethods.html#M001483">transaction</a> block need not all be
instances of that class. This is because transactions are per-database
connection, not per-model.
</p>
<p>
In this example a <tt>Balance</tt> record is transactionally saved even
though <tt><a href="ClassMethods.html#M001483">transaction</a></tt> is
called on the <tt>Account</tt> class:
</p>
<pre>
  Account.transaction do
    balance.save!
    account.save!
  end
</pre>
<p>
Note that the <tt><a href="ClassMethods.html#M001483">transaction</a></tt>
method is also available as a model instance method. For example, you can
also do this:
</p>
<pre>
  balance.transaction do
    balance.save!
    account.save!
  end
</pre>
<h2><a href="../Transactions.html">Transactions</a> are not distributed across database connections</h2>
<p>
A <a href="ClassMethods.html#M001483">transaction</a> acts on a single
database connection. If you have multiple class-specific databases, the <a
href="ClassMethods.html#M001483">transaction</a> will not protect
interaction among them. One workaround is to begin a <a
href="ClassMethods.html#M001483">transaction</a> on each class whose models
you alter:
</p>
<pre>
  Student.transaction do
    Course.transaction do
      course.enroll(student)
      student.units += course.units
    end
  end
</pre>
<p>
This is a poor solution, but full distributed transactions are beyond the
scope of Active Record.
</p>
<h2>Save and destroy are automatically wrapped in a <a href="ClassMethods.html#M001483">transaction</a></h2>
<p>
Both <a href="../Base.html#M001908">Base#save</a> and <a
href="../Base.html#M001851">Base#destroy</a> come wrapped in a <a
href="ClassMethods.html#M001483">transaction</a> that ensures that whatever
you do in validations or callbacks will happen under the protected cover of
a <a href="ClassMethods.html#M001483">transaction</a>. So you can use
validations to check for values that the <a
href="ClassMethods.html#M001483">transaction</a> depends on or you can
raise exceptions in the callbacks to rollback, including <tt>after_*</tt>
callbacks.
</p>
<h2>Exception handling and rolling back</h2>
<p>
Also have in mind that exceptions thrown within a <a
href="ClassMethods.html#M001483">transaction</a> block will be propagated
(after triggering the ROLLBACK), so you should be ready to catch those in
your application code.
</p>
<p>
One exception is the <a href="../Rollback.html">ActiveRecord::Rollback</a>
exception, which will trigger a ROLLBACK when raised, but not be re-raised
by the <a href="ClassMethods.html#M001483">transaction</a> block.
</p>
<p>
<b>Warning</b>: one should not catch <a
href="../StatementInvalid.html">ActiveRecord::StatementInvalid</a>
exceptions inside a <a href="ClassMethods.html#M001483">transaction</a>
block. <a href="../StatementInvalid.html">StatementInvalid</a> exceptions
indicate that an error occurred at the database level, for example when a
unique constraint is violated. On some database systems, such as
PostgreSQL, database errors inside a <a
href="ClassMethods.html#M001483">transaction</a> causes the entire <a
href="ClassMethods.html#M001483">transaction</a> to become unusable until
it&#8216;s restarted from the beginning. Here is an example which
demonstrates the problem:
</p>
<pre>
  # Suppose that we have a Number model with a unique column called 'i'.
  Number.transaction do
    Number.create(:i =&gt; 0)
    begin
      # This will raise a unique constraint error...
      Number.create(:i =&gt; 0)
    rescue ActiveRecord::StatementInvalid
      # ...which we ignore.
    end

    # On PostgreSQL, the transaction is now unusable. The following
    # statement will cause a PostgreSQL error, even though the unique
    # constraint is no longer violated:
    Number.create(:i =&gt; 1)
    # =&gt; &quot;PGError: ERROR:  current transaction is aborted, commands
    #     ignored until end of transaction block&quot;
  end
</pre>
<p>
One should restart the entire <a
href="ClassMethods.html#M001483">transaction</a> if a StatementError
occurred.
</p>
</div></fieldset>



<h2>Methods</h2>
<fieldset>
<div class="row">
<ul>
<li><a href="#M001483">transaction</a></li>
</ul>
</div>
</fieldset>  






<h2>Public Instance methods</h2>
<h2><a name="M001483">transaction</a> (&amp;block)</h2>

<fieldset><div class='row'><p>
See <a
href="ClassMethods.html">ActiveRecord::Transactions::ClassMethods</a> for
detailed documentation.
</p></div></fieldset>



</div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-1377203-4");
pageTracker._trackPageview();
} catch(err) {}</script>

  </body>
</html>